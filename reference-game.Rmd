---
title: "reference-game"
output: html_document
---

## Process MTurk Data

```{r, echo=FALSE}
library(jsonlite)
library(dplyr)
library(ggplot2)
library(tidyr)
library(lubridate)

theme_set(theme_bw())

setwd(dirname(rstudioapi::getActiveDocumentContext()$path))


filenames <- list.files("12.5_reference_100_30/production-results/", pattern="*.json", full.names = TRUE)
ldf <- lapply(filenames, fromJSON)
res <- lapply(ldf, summary)

timing <- NULL
ruleCheck <- NULL
game <- NULL
test<- NULL
attn <- NULL
for (i in 1:length(ldf)) {
  janeDoe <- ldf[[i]]
  # anyAttn <- ifelse(length(janeDoe$answers$data$attnCheck)!=0, 1,0)
  condition <- "100_30"
  subID <- i
  timing <- rbind(timing, as.data.frame(
      cbind(subID, start= janeDoe$AcceptTime,stop = janeDoe$SubmitTime)))
  ruleCheck <- rbind(ruleCheck, cbind(subID, condition, janeDoe$answers$data$ruleQuestions))
  test <- rbind(test, cbind(subID, condition, janeDoe$answers$data$testTrials))
  game <- rbind(game,cbind(subID, condition, janeDoe$answers$data$gameTrials))
  if (length(janeDoe$answers$data$attnCheck)!=0) 
    {attn <- rbind(attn, cbind(subID, condition, janeDoe$answers$data$attnCheck))}
}

----------------

filenames <- list.files("12.5_reference_80_50/production-results/", pattern="*.json", full.names = TRUE)
ldf <- lapply(filenames, fromJSON)
for (i in 1:length(ldf)) {
  janeDoe <- ldf[[i]]
  # anyAttn <- ifelse(length(janeDoe$answers$data$attnCheck)!=0, 1,0)
  condition <- "80_50"
  subID <- nrow(ruleCheck) + 1
  timing <- rbind(timing, as.data.frame(
      cbind(subID, start= janeDoe$AcceptTime,stop = janeDoe$SubmitTime)))
  ruleCheck <- rbind(ruleCheck, cbind(subID, condition, janeDoe$answers$data$ruleQuestions))
  test <- rbind(test, cbind(subID, condition, janeDoe$answers$data$testTrials))
  game <- rbind(game,cbind(subID, condition, janeDoe$answers$data$gameTrials))
  if (length(janeDoe$answers$data$attnCheck)!=0) 
    {attn <- rbind(attn, cbind(subID, condition, janeDoe$answers$data$attnCheck))}
}


test <- test %>% mutate(responseCorrect = if_else(typedLabel == "UNKNOWN", as.integer(NA), responseCorrect))
```

## Basics: Duration, Attention...
```{r, echo=FALSE}
# How long do people take?
howLong <- as.duration(ymd_hms(timing$start) %--% ymd_hms(timing$stop))
sort(howLong)
mean(howLong)
median(howLong)

timing_good_Ps <- timing %>% filter(subID %in% rule_correct$subID)
timing_good_Ps$duration <- as.numeric(as.duration(ymd_hms(timing_good_Ps$start) %--% ymd_hms(timing_good_Ps$stop)))

under_20 <- timing_good_Ps %>%
  filter(duration < 20*60)

### Do people understand the rules?
#cleaning the data about knowledge of the game rules
# ruleCheck <- ruleCheck %>%
#     mutate(trueLabelPoints = ifelse(condition == "100_30", 100, 80)) %>%
#     mutate(trueClickPoints = ifelse(condition == "100_30", 30, 50))
# 
ruleCheck %>% 
#     mutate(labelCorrect = ifelse(pointsLabel == trueLabelPoints, 1, 0)) %>%
#     mutate(clickCorrect = ifelse(pointsClick == trueClickPoints, 1, 0)) %>%
#     mutate(wrongCorrect = ifelse(pointsWrong == 0, 1, 0)) %>%
    mutate(propQuestCorr = (clickCorrect+labelCorrect+wrongCorrect)/3)
    # select(-clickCorr, -labelCorr, -wrongCorr)
# 
# ruleCheck %>% group_by(propQuestCorr) %>% summarize(n())


# ruleCheck <- ruleCheck %>% select(subID, condition, pointsLabel, pointsClick, pointsWrong, pointsLabel, 
#                      labelCorrect, clickCorrect, wrongCorrect, timestamp )
ruleCheck %>% group_by(subID) %>% summarize(n())
ruleCorrect <- ruleCheck %>% filter(labelCorrect, clickCorrect, wrongCorrect)



# Final attention check
attended <- attn %>% 
    group_by(subID) %>% 
    summarize(numObj = n(), corrObj = mean(correctRecog))
attended <- attended %>%
    filter(numObj == 9, corrObj == 1) %>%
    select(subID)
  
attn %>% group_by(subID) %>% summarize(numObj = n(), corrObj = mean(correctRecog)) %>% group_by(numObj, corrObj) %>% summarize(n())


# Think about filtering subjects out
#select only those participants who knew all the rules before playing?
rule_correct <- ruleCheck %>%
  filter(! propQuestCorr == 1) %>%
  select(subID)

#cross section of attention check and rule check
best_folks <- ruleCheck %>% 
    filter(!subID %in% rule_correct$subID) %>% 
    # filter(subID %in% 
    # attended$subID) %>% 
    # select(subID) %>%
    # filter(subID %in% under_20$subID)

#----------
```



```{r}
#trying to weed out folks who are not doing the task as we'd expect 
#   do i have to do this manually
#some proxies that are automatic
   #folks who only use one method during the game?
only_one_method <- game %>% group_by(subID) %>% 
  summarize(muchLabelling=mean(method=='label')) %>%
  filter(muchLabelling==1 |muchLabelling==0)

  #folks who respond with long(er) responses?
too_many_letters <- game %>% 
  group_by(subID) %>% 
  mutate(nchar= ifelse(method=="label", 
                          nchar(typedLabel, type="chars"),
                          NA)) %>%
  summarize(avg_nchar = mean(nchar, na.rm=T)) %>%
  filter(avg_nchar > 6)

  #what is the overlap like?
too_many_letters$subID %in% only_one_method$subID


## manually dropping
manual_remove <- as.vector(c(8, 6, 32, 38,7))
    # maybe also 21?             
```


#recoding correct to take levenshtein distance into account
```{r}
# cannot use 'which.min' because it doesn't find two minimums when of the same value
  min(adist("tofa", novelWords), na.rm = TRUE)
  which(adist("tofa", novelWords) == min(adist("tofa", novelWords), na.rm = TRUE))
```




```{r}
novelWords <- as.vector(c("blicket", "kreeb", "dofa", "wug", "toma", "dax", "fep", "pifo", "modi"))

test2 <- test %>%
  rowwise() %>%
  mutate(testDistance = min(adist(typedLabel, novelWords))) %>%
  ## need ifelse because case of two identical minimums breaks the mutate by trying to return 2 elements
  ### hideous way of flipping a coin and randomly choosing that minimum in event of tie
  ###  if a three way (or more) tie is possible with these words, this code allows for it.
  mutate(testClosest = ifelse(length(which(adist(typedLabel, novelWords) == testDistance))==1,
           novelWords[which(adist(typedLabel, novelWords) == testDistance)],
           novelWords[which(adist(typedLabel, novelWords) == testDistance)[sample(1:
                        length(which(adist(typedLabel, novelWords) == testDistance)), 1)]])) %>%
  mutate(testCorrect = ifelse(testClosest==realLabel, 1, 0),
         testCorrect = if_else(typedLabel == "UNKNOWN", as.double(NA), testCorrect))

all_data <- game %>% 
  filter(!subID %in% too_many_letters$subID) %>%
  filter(!subID %in% manual_remove) %>%
  select(subID, trialnum, condition, exposureRate, method, responseCorrect, realLabel, typedLabel) %>%
  rename(communicationCorrect = responseCorrect) %>%
  # cannot use 'which.min' because it doesn't find two minimums when of the same value
  rowwise() %>%
  mutate(communicationDistance = min(adist(typedLabel, novelWords))) %>%
  ## need ifelse because case of two identical minimums breaks the mutate by trying to return 2 elements
  ### hideous way of flipping a coin and randomly choosing that minimum in event of tie
  ###  if a three way (or more) tie is possible with these words, this code allows for it.
  mutate(communicationClosest = ifelse(length(which(adist(typedLabel, novelWords) == communicationDistance))==1,
           novelWords[which(adist(typedLabel, novelWords) == communicationDistance)],
           novelWords[which(adist(typedLabel, novelWords) == communicationDistance)[sample(1:
                        length(which(adist(typedLabel, novelWords) == communicationDistance)), 1)]])) %>%
  mutate(communicationCorrected = ifelse(communicationClosest==realLabel, 1, 0)) %>%
#  left_join(select(test, subID, realLabel, responseCorrect)) %>%
   left_join(select(test2, subID, realLabel, testCorrect, responseCorrect)) %>%
   left_join(select(ruleCheck, subID, trueClickPoints, trueLabelPoints)) %>%
  # if condition allows for repeated questions about rule, use line below, not above
  # left_join(select(ruleCorrect, subID, trueClickPoints, trueLabelPoints)) %>%
  rename(known = responseCorrect) %>%
  mutate(point_utility = trueClickPoints,
         label_utility_perfect = trueLabelPoints*known) 
  # left_join(expKnow)


all_data_split <- all_data %>%
  group_by(subID, condition, exposureRate, realLabel) %>%
  mutate(firstTrial = factor(trialnum == min(trialnum), levels = c(TRUE, FALSE), 
                             labels = c("First", "Second")))
  
game_data <- all_data_split %>%
  group_by(condition, exposureRate, firstTrial, known, subID) %>%
  summarise(responseLabel = mean(method == "label")) %>%
  summarise_each(funs(mean, sem), responseLabel)


wrong_first_data <- all_data_split %>%
  left_join(select(game, subID, trialnum, typedLabel)) %>%
  arrange(condition, subID, exposureRate, realLabel, firstTrial) %>%
  mutate(lastResponse = factor(if_else(lag(method == "label"), "Label", "Point"), 
                               levels = c("Label", "Point")),
         lastCorrect = lag(communicationCorrected),
         lastLabel = lag(typedLabel)) %>%
  filter(lastResponse == "Label", !lastCorrect, method == "label") %>%
  ungroup() %>%
  select(subID,realLabel, typedLabel,lastLabel) %>%
  mutate(edit_dist = stringdist(typedLabel, realLabel, method = "lv"))


second_trial_data <- all_data_split %>%
  arrange(condition, subID, exposureRate, realLabel, firstTrial) %>%
  mutate(lastResponse = factor(if_else(lag(method == "label"), "Label", "Point"), 
                               levels = c("Label", "Point"))) %>%
  mutate(lastCorrect = lag(communicationCorrected)) %>%
  filter(firstTrial == "Second") %>%
  group_by(condition, exposureRate, lastResponse, lastCorrect, known, subID) %>%
  summarise(responseLabel = mean(method == "label", na.rm = T)) %>%
  summarise_each(funs(mean(., na.rm = T), sem(., na.rm = T)), responseLabel) %>%
  mutate(known = as.character(known)) %>%
  mutate(known = if_else(is.na(known), "unknown", known))


second_trial_counts <- all_data_split %>%
  arrange(condition, subID, exposureRate, realLabel, firstTrial) %>%
  mutate(lastResponse = factor(if_else(lag(method == "label"), "Label", "Point"), 
                               levels = c("Label", "Point"))) %>%
  mutate(lastCorrect = lag(communicationCorrect)) %>%
  filter(firstTrial == "Second") %>%
  group_by(condition, exposureRate, lastResponse, lastCorrect, known, method, subID) %>%
  summarise(n = n()) %>%
  summarise(n = mean(n)) %>%
  ungroup() %>%
  mutate(known = as.character(known)) %>%
  mutate(known = if_else(is.na(known), "unknown", known))

quartz(width = 10, height = 7)
ggplot(second_trial_data,
       aes(x = exposureRate, y = mean, color = lastResponse,
                              shape = known)) +
  facet_grid(lastCorrect ~ condition, labeller = label_both) +
  geom_pointrange(aes(ymin = mean - sem, ymax = mean + sem), 
                  position = position_dodge(.5)) + 
  scale_y_continuous(limits = c(0,1))

quartz(width = 10, height = 7)
ggplot(filter(second_trial_counts, lastResponse == "Label"),
       aes(x = exposureRate, y = n, color = method,
                              shape = known)) +
  facet_grid(lastCorrect ~ condition, labeller = label_both) +
  geom_point(size = 2, position = position_dodge(.5))

quartz(width = 10, height = 7)
ggplot(game_data, aes(x = exposureRate, y = mean, color = firstTrial)) +
  facet_grid(known ~ condition) +
  geom_pointrange(aes(ymin = mean - sem, ymax = mean + sem), 
                  position = position_dodge(.5)) + 
  scale_y_continuous(limits = c(0,1))




#also seems like I could just do some careful sorting, than introduce 'first or second' directly
novelWords <- as.vector(c("blicket", "kreeb", "dofa", "wug", "toma", "dax", "fep", "pifo", "modi"))
all_data_split <- NULL
for (i in 1:length(novelWords)) {
  one_Word <- all_data %>%
      filter(realLabel == novelWords[i]) %>%
      mutate(firstOrSecond = rep(c(1,2), nrow(timing)))
  all_data_split <- bind_rows(all_data_split, one_Word)
}

#for game trial two, want to take into account whether they got it right on trial one
all_data_split <- all_data_split %>% 
  mutate(label_utility_perfect = ifelse(firstOrSecond == 2, 
                                        label_utility_perfect * communicationCorrect, 
                                        label_utility_perfect))

seprop <- function(props) {
  mean_prop = mean(props)
  mean_prop * sqrt((1 - mean_prop)/length(props))
}

label_props <- all_data_split %>%
  # mutate(point_utility = point_utility,
  #        label_utility_perfect = label_utility_perfect*U_Label) %>%
  group_by(condition, exposureRate, firstOrSecond,  subID) %>%
  # summarise(theoretical = mean(label_utility_perfect > point_utility),
  #        empirical = mean(method == "label")) %>%
  summarise(theoretical = sum(label_utility_perfect)/
              (sum(label_utility_perfect + point_utility)),
            empirical = mean(method == "label")) %>%
  summarise_each(funs(mean, seprop), c(theoretical, empirical))

group_ns <- all_data_split %>% group_by(condition, exposureRate, firstOrSecond, subID) %>%
  distinct() %>%
  group_by(condition, exposureRate, firstOrSecond) %>%
  summarise(n = n())

wide_label_props <- label_props %>%
  gather(measure, value, - exposureRate, -condition, -firstOrSecond) %>%
  separate(measure, c("measure", "type")) %>%
  spread(type, value) %>%
  left_join(group_ns)

wide_label_props %>% 
  # filter(condition=="100_30") %>%
  ggplot( aes(x = log(exposureRate), y = mean, 
                             color = condition, shape=measure, linetype= as.factor(firstOrSecond))) +
  geom_pointrange(aes(ymax = mean + seprop, ymin = mean - seprop), 
                  position = position_dodge(.5)) +
  theme_bw()




test_data <- test %>%
#   filter(subID %in% best_folks$subID) %>%
  group_by(condition, exposureRate, subID) %>%
  summarise(correct = mean(responseCorrect)) %>%
  summarise(correct = mean(correct), n = n())


predicted_props <- old_wide_label_props %>% 
  mutate(type = "original") %>% 
  bind_rows(mutate(wide_label_props, type = "new"))

ggplot(predicted_props, aes(x = log(exposureRate), y = mean, color = type)) +
  facet_wrap(~ measure) +
  geom_pointrange(aes(ymax = mean + seprop, ymin = mean - seprop))


```








### Old stuff for Pack-Ratting

# Simple descriptives about how folks are doing...
```{r}
### How are people learning
# Average 1/3 correct, range from 11% - 67%
test_score <- test %>% group_by(subID) %>% summarize(propCorr = mean(responseCorrect))
expKnow <- test %>% group_by(exposureRate) %>% summarize(U_label = mean(responseCorrect)) %>%
  mutate(U2_label = U_label*U_label)
#----------


### How are people doing on the game?
# 62% of trials, people were clicking. heterogeneous clicking rate across folks
game %>% group_by(method) %>% summarize(n())
  #need to deal with label_click trials, just drop them?
game %>% 
    filter(subID %in% rule_correct$subID) %>%
    group_by(condition) %>% 
    summarize(propGameClick = mean(method=='click'))

# overall mostly correct (89% of trials). always correct for clicking.
game %>% summarize(mean(responseCorrect))
game %>% group_by(method) %>% summarize(mean(responseCorrect))

# folks send a good message with more exposure. when using labels. 
game %>% group_by(exposureRate) %>% summarize(mean(responseCorrect))
game %>% group_by(method, exposureRate) %>% summarize(mean(responseCorrect))
# people seem to label more with more exposure 
game %>% group_by(condition, method, exposureRate) %>% summarize(n())


#### my old bad code?
tmp <- left_join(game, test, by=c("subID", "targetObjectName"))
  # filter(subID %in% rule_correct$subID)
tmp %>% group_by(method, responseCorrect.y) %>% summarize(mean(responseCorrect.x))
#big split, if known at test --> seemingly more likely ot label. 
# need to get subject level
tmp %>% group_by(method, responseCorrect.y) %>% summarize(n())
expKnow %>%
  mutate(U_label= U_label*pointsForLabel, U2_label=U2_label*pointsForLabel) %>%
  mutate(pLabel = (U_label)/(U_label + pointsForClick), pLabel2= (U2_label)/(U2_label + pointsForClick))
tmp2 <- left_join(tmp, expKnow, by=c('exposureRate.x'='exposureRate')) %>%
  mutate(U_label= U_label*pointsForLabel, U2_label=U2_label*pointsForLabel) %>%
  mutate(pLabel = (U_label)/(U_label + pointsForClick), pLabel2= (U2_label)/(U2_label + pointsForClick))
tmp2 %>% group_by(exposureRate.x) %>%  summarize(labelling = mean(method=='label'), avgPLabel= mean(pLabel), avgPLabel2= mean(pLabel2))
#----------------------


```

#old Dan plots...
```{r}
tabulation <- tmp %>%
  group_by(method, responseCorrect.x, responseCorrect.y, exposureRate.x) %>%
  summarise(n = n()) %>%
  group_by(method, exposureRate.x) %>%
  mutate(n = n/sum(n))

ggplot(tabulation, aes(y =  responseCorrect.x, x = responseCorrect.y, fill = n)) + 
  facet_grid(exposureRate.x ~ method) + 
  geom_tile() + 
  theme_bw() + 
  scale_fill_gradient(low = "white", high = "black")

ggplot(tmp, aes(y =  responseCorrect.x, x = as.factor(responseCorrect.y), color = method)) + 
  facet_grid(exposureRate.x ~ .) + 
  geom_jitter(width = .1) +
  theme_bw() 

```






